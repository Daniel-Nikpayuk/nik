/************************************************************************************************************************
**
** Copyright 2015-2019 Daniel Nikpayuk, Inuit Nunangat, The Inuit Nation
**
** This file is part of nik.
**
** nik is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
**
** nik is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
** of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License along with nik. If not, see
** <http://www.gnu.org/licenses/>.
**
************************************************************************************************************************/


/*
	C++ core deduction system:


		judgement		:=	( instance           : type               )


		register_judgement	:=	( value_instance     : value_type         )

						( boolean            : bool               )
						( literal            : unsigned char      )
						( literal            : signed   char      )
						( numeric            : unsigned short     )
						( numeric            : signed   short     )
						( numeric            : unsigned int       )
						( numeric            : signed   int       )
						( numeric            : unsigned long      )
						( numeric            : signed   long      )
						( numeric            : unsigned long long )
						( numeric            : signed   long long )
						( numeric            : pointer            )


		address_judgement	:=	( object_instance    : object_type        )

						( initialization     : array              )
						( struct             : abstraction        )
						( specialization     : template           )


		symbolic_judgement	:=	( parameter_instance : parameter_type     )

						( value_instance     : value_type         )
						( value_type         : typename           )
						( abstraction        : typename           )
						( template           : typename           )


/***********************************************************************************************************************/


	Nik library symbolic lens deduction system:


		alias			:=	( terminal_name      : initial_name       )

						( builtin            : value_type         )


	1. A computable space is a class of duals.
	2. Duals have states.
	3. Dual states: judgements; patches.
	4. A patch can be viewed as an evaluation code with respect to a dual's judgement.
	5. Patches are partitioned as follows:


		reflex				a) Reflexive patches evaluate instances to themselves.

							reflex_A : A --> A

						b) Reflexes are divided based on their judgement types.

							echo : builtin  --> builtin
							ping : typename --> typename

		transit				a) Transitive patches correspond to type theoretic function objects

							transit_{A, B} : (A --> B) x A --> B

						b) Transits are divided based on local implementation grammar.

							static constexpr:

								pose : ( builtin  --> builtin  ) x builtin  --> builtin

							using alias:

								turn : ( typename --> builtin  ) x typename --> builtin
								moiz : ( builtin  --> typename ) x builtin  --> typename
								call : ( typename --> typename ) x typename --> typename


	6. Let A, B, C be types, with f : B --> C. The compositional form of f with respect to A is defined to be

		f_A : (A --> B) x A --> C

		    := f . transit_{A, B}

	   These definitions allow us to declare grammar with what is otherwise function object (delayed; lazy) input.
	   Such function objects themselves may be constructed under various local grammatical implementations, and in
	   practice might not even be defined strictly as a single object.

	   These objects also suggest grammatical forms having typed input, composed with various transits, are the bare
	   minimum requirements for compositional robustness. If a particular form is common enough it can then be
	   optimized---when effective to do so.

	7. The existence of transits allows for the apriori/aposteriori paradigm: Refined specifications can be optimized,
	   and if the context is known in advanced the appropriate optimization can be dispatched manually. Otherwise,
	   a generic version is then needed to pattern match and dispatch automatically.

	8. Builtin template templates are not composable, and parameter packs are not objects (C++ standard). As a consequence,
	   whenever a builtin or a parameter pack is (stand alone) returned from a symbolic function, it is a best practice
	   to adhere to the continuation passing paradigm. This allows for composability while minimizing memoization.

	9. This library privileges the combinatorial paradigm: Minimalist grammatical forms are composed to implement composite
	   grammatical forms. The combinatorial space of such compositions is associated with its given module, and any
	   composite form is only reimplemented if it can be optimized effectively away from its composed minimal forms.

	   In other words: Lazy implementation of grammar while acknowledging the appropriate extensional location if and
	   when it is reimplemented as an optimization.


/***********************************************************************************************************************/


		dual			:=	( judgement                               ; patch           )


		symbolic_dual		:=	( parameter_instance : parameter_type     ; parameter_patch )

						( value_instance     : builtin            ; echo            )
						( value_instance     : builtin            ; pose            )
						( value_instance     : builtin            ; moiz            )
						( value_type         : typename           ; ping            )
						( abstraction        : typename           ; turn            )
						( abstraction        : typename           ; call            )
						( template           : typename           ; turn            )
						( template           : typename           ; call            )
*/

