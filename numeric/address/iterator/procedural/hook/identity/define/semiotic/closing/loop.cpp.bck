/*************************************************************************************************************************
**
** Copyright 2015, 2016 Daniel Nikpayuk, Inuit Nunangat, The Inuit Nation
**
** This file is part of nik.
**
** nik is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
**
** nik is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
** of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License along with nik. If not, see
** <http://www.gnu.org/licenses/>.
**
*************************************************************************************************************************/

/*
	This code is not intended to be used standalone.
	It needs to be equipped with a context to be interpreted by the compiler.
*/

/*
	Keep in mind you can always specify the template type to be a reference if need be (in1, in2, end2).

	These methods are less iterator algorithms than they are iterator reference algorithms---data algorithms
	in the special case where the data is only accessible through iterators.

	As "out" is assign shifted when its "+out" is allocated, there is no need to increment seperately.
*/

/************************************************************************************************************************/

/*
	Constraints:

	[in, end), in != end
*/

#define _closing_loop_pop_left(interval, dir, inv, label, rtn, stmt) \
template<typename WNode, typename WPointer, typename RIterator, typename ERIterator> \
static rtn label##_return(WPointer out, RIterator in, ERIterator end) \
{ \
	stmt zip::assign::interval::template label##_return<WNode>(out, +in, end); \
}

#define closing_loop_no_return_pop_left(interval, dir, inv)		_closing_loop_pop_left(interval, dir, inv, no, void, )
#define closing_loop_with_return_pop_left(interval, dir, inv)		_closing_loop_pop_left(interval, dir, inv, with, WPointer, return)

/************************************************************************************************************************/

/*
	Constraints:

	[in, end), in != end
*/

#define _closing_loop_pop_right(interval, dir, inv, label, rtn, stmt) \
template<typename WNode, typename WPointer, typename RIterator, typename ERIterator> \
static rtn label##_return(WPointer out, RIterator in, ERIterator end) \
{ \
	while (dir(in) != end) \
	{ \
		*out=*in; \
		out=dir(out)=new WNode; \
		dir##dir(in); \
	} \
 \
	*out=*in; \
 \
	stmt \
}

#define closing_loop_no_return_pop_right(interval, dir, inv)	_closing_loop_pop_right(interval, dir, inv, no, void, )
#define closing_loop_with_return_pop_right(interval, dir, inv)	_closing_loop_pop_right(interval, dir, inv, with, WPointer, return out;)

/*
struct assign
{
	struct pop
	{
		struct left
		{
			template<typename WPointer>
			static void no_return(WPointer initial)
			{
				delete initial;
			}

			template<typename WPointer>
			static WPointer with_return(WPointer initial)
			{
				WPointer out=+initial;
				delete initial;

				return out;
			}
		};
		struct right
		{
			template<typename WPointer, typename EWIterator>
			static void no_return(WPointer out, EWPointer end)
			{
				delete +find::before::end::with_return(out, end);
			}

			template<typename WPointer, typename EWPointer>
			static WPointer with_return(WPointer out, EWPointer end)
			{
				out=find::before::end::with_return(out, end);
				delete +out;

				return out;
			}

			template<typename WPointer, typename EWPointer>
			static WPointer before_return(WPointer out, EWPointer end)
			{
				out=find::before::last::with_return(out, end);
				delete +(+out);

				return out;
			}
		};
	};

	struct push
	{
		struct left
		{
			template<typename WNode, typename WPointer, typename RIterator, typename ERIterator>
			static void no_return(WPointer out, RIterator in, ERIterator end)
			{
				while (+in != end)
				{
					*out=*in;
					out=+out=new WNode;
					++in;
				}

				*out=*in;
			}

			template<typename WNode, typename WPointer, typename RIterator, typename ERIterator>
			static WPointer with_return(WPointer out, RIterator in, ERIterator end)
			{
				while (+in != end)
				{
					*out=*in;
					out=+out=new WNode;
					++in;
				}

				*out=*in;

				return out;
			}

			struct before
			{
			};
		};
	};
};
*/

