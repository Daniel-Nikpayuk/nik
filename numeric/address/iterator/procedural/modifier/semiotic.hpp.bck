/************************************************************************************************************************
**
** Copyright 2015, 2016, 2017 Daniel Nikpayuk, Inuit Nunangat, The Inuit Nation
**
** This file is part of nik.
**
** nik is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
**
** nik is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
** of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License along with nik. If not, see
** <http://www.gnu.org/licenses/>.
**
************************************************************************************************************************/


template<typename... params>
struct modifier;


template
<
	typename VerbRelation,
	typename VerbOrdering,
	typename VerbPartition,

	typename SubjectRelation,
	typename SubjectOrdering,
	typename SubjectPartition
>
struct modifier
<
	VerbRelation,
	VerbOrdering,
	VerbPartition,

	SubjectRelation,
	SubjectOrdering,
	SubjectPartition
>
{
	template<VerbRelation... params>
	using verb_mask = typename bit::mask::template cast
	<
		typename sortFill<VerbOrdering, VerbRelation, params...>::rtn
	>;

	template<size_type mask>
	using verb_base = match<mask, VerbPartition>;

/***********************************************************************************************************************/

	template<size_type mask, size_type base, typename... params>
	struct adverb;

	template<size_type mask, typename F>
	struct adverb
	<
		mask,
		verb_base<mask>::rtn,
		F
	> :

			public functor_F<mask, F>,
			public count<mask>

	{
		adverb(const F & f) : functor_F<mask, F>(f) { }
	};

	template<size_type mask>
	struct adverb
	<
		mask,
		verb_base<mask>::rtn
	> :

			public functor<mask>,
			public count<mask>

		{ };

/***********************************************************************************************************************/

	template<size_type mask>
	using functor_cast = apply< deduct<mask, Functor>::rtn, ApplyFunctor>;

	template<size_type mask, typename F>
	using functor_adverb = adverb<functor_cast<mask>::rtn, verb_base<mask>::rtn, F>;

	template<size_type mask, size_type base, typename F>
	static functor_adverb<mask, F> apply_functor(const adverb<mask, base> &, const F & f)
	{
		return functor_adverb<mask, F>(f);
	}

/***********************************************************************************************************************/

	template<size_type mask>
	using tracer_cast = apply< deduct<mask, Tracer>::rtn, ApplyCount>;

	template<size_type mask>
	using tracer_adverb = adverb<tracer_cast<mask>::rtn, verb_base<mask>::rtn>;

	template<size_type mask, size_type base>
	static tracer_adverb<mask> apply_count(const adverb<mask, base> &, const size_type & c)
	{
		return tracer_adverb<mask>(c);
	}

/***********************************************************************************************************************/

	template<VerbRelation... params>
	using verb = adverb
	<
		verb_mask<params...>::rtn,
		verb_base<verb_mask<params...>::rtn>::rtn
	>;


/***********************************************************************************************************************/
/***********************************************************************************************************************/


	template<SubjectRelation... params>
	using sub_mask = typename bit::mask::template cast
	<
		typename sortFill<SubjectOrdering, SubjectRelation, params...>::rtn
	>;

	template<size_type mask>
	using sub_base = match<mask, SubjectPartition>;

/***********************************************************************************************************************/

	template<size_type mask, size_type base, typename... params>
	struct adjective;

	template<size_type mask, typename T>
	struct adjective
	<
		mask,
		sub_base<mask>::rtn,
		T
	> :

			public memory_T<mask, T>

	{
		adjective(T *o) : memory_T<mask, T>(o) { }
	};


	template<size_type mask>
	struct adjective
	<
		mask,
		sub_base<mask>::rtn
	> :

			public iterate<mask>

	{
		adjective() : iterate<mask>() { }
		adjective(size_type l, size_type o) : iterate<mask>(l, o) { }
	};

/***********************************************************************************************************************/

	template<size_type mask>
	using allocate_cast = apply< deduct<mask, Image>::rtn, AllocateSegment>;

	template<size_type mask>
	using allocate_adjective = adjective<allocate_cast<mask>::rtn, sub_base<mask>::rtn>;

	template<size_type mask, size_type base>
	static allocate_adjective<mask> allocate_segment(const adjective<mask, base> &, size_type l, size_type o = 0)
	{
		return allocate_adjective<mask>(l, o);
	}

/***********************************************************************************************************************/

	template<size_type mask>
	using deallocate_cast = apply< deduct<mask, Image>::rtn, DeallocateSegment>;

	template<size_type mask, typename T>
	using deallocate_adjective = adjective<deallocate_cast<mask>::rtn, sub_base<mask>::rtn, T>;

	template<size_type mask, size_type base, typename T>
	static deallocate_adjective<mask, T> deallocate_segment(const adjective<mask, base> &, T *o)
	{
		return deallocate_adjective<mask, T>(o);
	}

/***********************************************************************************************************************/

	template<SubjectRelation... params>
	using subject = adjective
	<
		sub_mask<params...>::rtn,
		sub_base<sub_mask<params...>::rtn>::rtn
	>;
};


