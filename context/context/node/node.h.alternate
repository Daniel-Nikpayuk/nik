/*************************************************************************************************************************
**
** Copyright 2015, 2016 Daniel Nikpayuk, Inuit Nunangat, The Inuit Nation
**
** This file is part of nik.
**
** nik is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
**
** nik is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
** of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License along with nik. If not, see
** <http://www.gnu.org/licenses/>.
**
*************************************************************************************************************************/

#ifndef NIK_CONTEXT_CONTEXT_POINTER_H
#define NIK_CONTEXT_CONTEXT_POINTER_H

#include<stddef.h>

/*
	This class is meant to be as narratively similar as possible to the builtin array node_pointer.

	It is intuitive that node_pointers should be able to convert to const_node_pointers, the design follows this intuition.

	In terms of dynamic binding, const_node_pointers can semantically be considered a node_pointer subclass,
	and is nearly implemented as such. As it stands, I have decided to prevent this use of polymorphism,
	and have implemented this code in such a way that the compiler will allow no such direct conversion.
	Otherwise, I have defined hook as well as chain pointers as semantically related allowing polymorphism
	through their common base class node_pointer.

	It takes a policy of soft or shallow copying, and does not delete or destroy by default.

	void node_pointer casting is subtle, as the same memory cast to two different types works, but referencing within such memory
	changes on the interpretation of the type of that memory.

	By defining the node before the node_pointer, we can call "new node()" outside of the pointer's scope,
	the tradeoff is the extended namespace calling in order to do so (nik::context::context:: ...).
	One would need to typedef both the node_pointer as well as the node. The complication here is in needing to specify
	the same template parameters for both.

	Some coders may wish to still do this, and so it is policy to leave the definition of node outside the node_pointer
	scope, but for those coders looking to refactor specifying the template parameters, I have included a typedef of
	the node within its respective specialized node_pointer. This way the only scoping needed is "new node_pointer::node()".

	Intermixing polymorphism and void* seems to cause issues. Though I don't fully understand why, I resolved a bug by
	removing the virtual declarations of the (*) and (+) operator overloads. The bug arose when they combined (*+).
*/

namespace nik
{
 namespace context
 {
  namespace context
  {
	template<typename T, typename Pointer, typename SizeType, SizeType N>
	struct node
	{
		typedef node<T const, Pointer, SizeType, N> const_node;
		typedef T value_type;
		typedef Pointer pointer;

		node() { }
		node(const node & p)
		{
			value=p.value;
			array=p.array;
		}
		~node() { }

		const node & operator = (const node & p)
		{
			value=p.value;
			array=p.array;
			return *this;
		}

		operator const const_node & () const
			{ return *((const_node*) this); }

		value_type value;
		pointer array[N];
	};

	template<typename T, typename SizeType, SizeType N>
	class node_pointer
	{
		protected:
			typedef node_pointer* node_pointer_ptr;
			typedef node_pointer& node_pointer_ref;
			typedef node_pointer<T const, SizeType, N> const_node_pointer;
			typedef node<T, node_pointer, SizeType, N>* node_ptr;

			typedef T* value_type_ptr;
			typedef T& value_type_ref;

			typedef SizeType size_type;
			enum : size_type { next=0, previous=1 };

			typedef void* void_ptr;

			node_ptr current;
		public:
			enum : size_type { dimension=N };

			node_pointer() { }
			node_pointer(node_ptr p) { current=p; }
			node_pointer(const node_pointer & p) { current=p.current; }
			~node_pointer() { }
/*
	This version is needed for compatibility with the existing constructors, to accept "=new node()" code.
	Allows for potential memory leak. Burden is placed on the api coder.
*/
			const node_pointer & operator = (node_ptr p)
			{
				current=p;
				return *this;
			}
/*
	In the case &p == this, nothing is changed.
	Allows for potential memory leak. Burden is placed on the api coder.
*/
			const node_pointer & operator = (const node_pointer & p)
			{
				current=p.current;
				return *this;
			}

			static void operator delete (void_ptr p)
				{ delete ((node_pointer_ptr) p)->current; }
/*
	Needed for delete conversion.
*/
			operator node_pointer_ptr () const
				{ return (node_pointer_ptr) this; }
/*
	Needed for implicit const conversions.
*/
			operator const const_node_pointer & () const
				{ return *((const_node_pointer*) this); }
/*
	Needed for loop condition testing "while (node_pointer)".
*/
			operator bool () const
				{ return current; }

			bool operator == (const node_pointer & p) const
				{ return (current == p.current); }

			bool operator != (const node_pointer & p) const
				{ return (current != p.current); }

			value_type_ref operator * () const
				{ return current->value; }

			value_type_ptr operator -> () const
				{ return current->value; }

			node_pointer_ref operator + () const
				{ return current->array[next]; }

			node_pointer_ref operator ++ ()
			{
				current=current->array[next].current;
				return *this;
			}

			node_pointer operator ++ (int)
			{
				node_pointer out(*this);
				current=current->array[next].current;
				return out;
			}

			node_pointer_ref operator += (size_type n)
			{
				while (n)
				{
					current=current->array[next].current;
					--n;
				}

				return *this;
			}

			node_pointer operator + (size_type n) const
			{
				node_pointer out(*this);
				while (n)
				{
					out.current=out.current->array[next].current;
					--n;
				}

				return out;
			}

			node_pointer_ref operator - () const
				{ return current->array[previous]; }

			node_pointer_ref operator -- ()
			{
				current=current->array[previous].current;
				return *this;
			}

			node_pointer operator -- (int)
			{
				node_pointer out(*this);
				current=current->array[previous].current;
				return out;
			}

			node_pointer_ref operator -= (size_type n)
			{
				while (n)
				{
					current=current->array[previous].current;
					--n;
				}

				return *this;
			}

			node_pointer operator - (size_type n) const
			{
				node_pointer out(*this);
				while (n)
				{
					out.current=out.current->array[previous].current;
					--n;
				}

				return out;
			}
	};
/*
	GCC 4.8.4 crashes when declaring a const_node_pointer if an uninitialized pointer has been dereferenced in the existing code.

	Dereferencing an uninitialized pointer has undefined behaviour to begin with, and in practice would not happen anyway.
	The policy here might change to initialize the pointer array member in the above pointer class to be zero,
	but for now narrative consistency is preferred.
*/
	template<typename T, typename Pointer, typename SizeType, SizeType N>
	struct const_node : public node<T const, Pointer, SizeType, N>
	{
		typedef node<T const, Pointer, SizeType, N> base;
		typedef T const value_type;
		typedef Pointer pointer;

		const_node() { }
		const_node(const base & p) : base::node(p) { }
		const_node(const const_node & p) : base::node(p) { }
		~const_node() { }

		const const_node & operator = (const base & p)
		{
			base::operator=(p);
			return *this;
		}

		const const_node & operator = (const const_node & p)
		{
			base::operator=(p);
			return *this;
		}
	};

	template<typename T, typename SizeType, SizeType N>
	class const_node_pointer : public node_pointer<T const, SizeType, N>
	{
		private:
			typedef node_pointer<T const, SizeType, N> base;
			typedef node<T const, node_pointer<T const, SizeType, N>, SizeType, N>* const_node_ptr;

			typedef typename base::value_type_ptr value_type_ptr;
			typedef typename base::value_type_ref value_type_ref;
		public:
			const_node_pointer() { }
			const_node_pointer(const base & p) : base::node_pointer(p) { }
			const_node_pointer(const_node_ptr p) : base::node_pointer(p) { }
			const_node_pointer(const const_node_pointer & p) : base::node_pointer(p) { }
			~const_node_pointer() { }

			const const_node_pointer & operator = (const base & p)
			{
				base::operator=(p);
				return *this;
			}

			const const_node_pointer & operator = (const_node_ptr p)
			{
				base::operator=(p);
				return *this;
			}

			const const_node_pointer & operator = (const const_node_pointer & p)
			{
				base::operator=(p);
				return *this;
			}

			value_type_ref operator * () const
				{ return base::current->array[base::value]; }

			value_type_ptr operator -> () const
				{ return base::current->array[base::value]; }
	};

	#define HOOK_SIZE 2

	template<typename T, typename SizeType=size_t>
	using hook=node<T, node_pointer<T, SizeType, HOOK_SIZE>, SizeType, HOOK_SIZE>;

	template<typename T, typename SizeType=size_t>
	using hook_pointer=typename hook<T, SizeType>::pointer;

	template<typename T, typename SizeType=size_t>
	using const_hook=const_node<T, const_node_pointer<T, SizeType, HOOK_SIZE>, SizeType, HOOK_SIZE>;

	template<typename T, typename SizeType=size_t>
	using const_hook_pointer=typename const_hook<T, SizeType>::pointer;


	#undef HOOK_SIZE
	#define LINK_SIZE 3

	#undef LINK_SIZE
  }
 }
}

#endif
