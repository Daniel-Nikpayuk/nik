/*************************************************************************************************************************
**
** Copyright 2015, 2016 Daniel Nikpayuk, Inuit Nunangat, The Inuit Nation
**
** This file is part of nik.
**
** nik is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
**
** nik is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
** of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License along with nik. If not, see
** <http://www.gnu.org/licenses/>.
**
*************************************************************************************************************************/

#ifndef NIK_CONTEXT_CONTEXT_POINTER_H
#define NIK_CONTEXT_CONTEXT_POINTER_H

#include<stddef.h>

/*
	This class is meant to be as narratively similar as possible to the builtin array pointer.

	It is natural that unit::pointers should be able to convert to unit::const_pointers, as such within the unit::const_pointer
	class there is a conversion constructor---thus the additional need to (at least) declare the existence of the unit::pointer
	class ahead of time.

	In terms of dynamic binding, unit::const_pointers can semantically be considered a unit::pointer subclass,
	and is nearly implemented as such. As it stands, I have decided to prevent the use of polymorphism,
	and have implemented this code in such a way that the compiler will allow no such direct conversion.

	It takes a policy of soft or shallow copying, and does not delete or destroy by default.

	void pointer casting is subtle, as the same memory cast to two different types works, but referencing within such memory
	changes on the interpretation of the type of that memory.

	A proper amount of memory needs to be allocated for "current" when constructed,
	otherwise there will be subtle and strange bugs and behaviours!
*/

namespace nik
{
 namespace context
 {
  namespace context
  {
	template<typename T, typename SizeType, SizeType N>
	class pointer
	{
		protected:
			typedef pointer* pointer_ptr;
			typedef pointer& pointer_ref;
			typedef pointer_ptr& pointer_ptr_ref;

			typedef T value_type;
			typedef T* value_type_ptr;
			typedef T& value_type_ref;

			typedef void* void_ptr;
			typedef void_ptr* void_ptr_ptr;
			typedef void_ptr const* void_ptr_const_ptr; // array type []

			typedef pointer<T const, SizeType, N> const_pointer;

			typedef SizeType size_type;

			enum : size_type { value=0, next=1, previous=2, dimension=N };

				// an array of unknown types.
			void_ptr_ptr current;
		public:
			pointer() { }
			~pointer() { }

			virtual pointer_ptr*& operator & () const				// for debugging!
				{ return (pointer_ptr*&) current; }
/*
	Sufficient? Or does this cause memory leaks?
*/
			static void operator delete (void_ptr p)
				{ delete ((pointer_ptr) p)->current; }
/*
	Needed for loop condition testing "while (pointer)".
*/
			operator bool () const
				{ return current; }
/*
	Needed for delete conversion.
*/
			operator pointer_ptr () const
				{ return (pointer_ptr) this; }
/*
	Needed for implicit const conversions.
*/
			operator const const_pointer & () const
				{ return *((const_pointer*) this); }
/*
	Broader definitions of equality comparison.
*/
			bool operator == (const pointer & p) const
				{ return (current == p.current); }
/*
	Broader definitions of inequality comparison.
*/
			bool operator != (const pointer & p) const
				{ return (current != p.current); }
/*
	Virtually defined as const_pointer redefines it.
*/
			virtual value_type_ref operator * () const
				{ return (value_type_ref) current[value]; }
/*
	Virtually defined as const_pointer redefines it.
*/
			virtual value_type_ptr operator -> () const
				{ return (value_type_ptr) current[value]; }

			pointer_ptr_ref operator + () const
				{ return (pointer_ptr_ref) current[next]; }

			pointer_ref operator ++ ()
			{
				current=((pointer_ptr) current[next])->current;
				return *this;
			}

			pointer operator ++ (int)
			{
				pointer out(*this);
				current=((pointer_ptr) current[next])->current;
				return out;
			}

			pointer_ref operator += (size_type n)
			{
				while (n)
				{
					current=((pointer_ptr) current[next])->current;
					--n;
				}

				return *this;
			}

			pointer operator + (size_type n) const
			{
				pointer out(*this);
				while (n)
				{
					out.current=((pointer_ptr) out.current[next])->current;
					--n;
				}

				return out;
			}

			pointer_ptr_ref operator - () const
				{ return (pointer_ptr_ref) current[previous]; }

			pointer_ref operator -- ()
			{
				current=((pointer_ptr) current[previous])->current;
				return *this;
			}

			pointer operator -- (int)
			{
				pointer out(*this);
				current=((pointer_ptr) current[previous])->current;
				return out;
			}

			pointer_ref operator -= (size_type n)
			{
				while (n)
				{
					current=((pointer_ptr) current[previous])->current;
					--n;
				}

				return *this;
			}

			pointer operator - (size_type n) const
			{
				pointer out(*this);
				while (n)
				{
					out.current=((pointer_ptr) out.current[previous])->current;
					--n;
				}

				return out;
			}
	};

	template<typename T, typename SizeType=size_t>
	class hook_pointer : public pointer<T, SizeType, 2>
	{
		protected:
			typedef pointer<T, SizeType, 2> base;
			typedef typename base::pointer_ptr hook_pointer_ptr;
			typedef typename base::pointer_ref hook_pointer_ref;
			typedef typename base::pointer_ptr_ref hook_pointer_ptr_ref;

			typedef void* void_ptr;
			typedef void_ptr* void_ptr_ptr;
		public:
			struct hook
			{
				static void_ptr operator new (size_t n)
					{ return new void_ptr[base::dimension]; }
			};
		protected:
			typedef hook* hook_ptr;
		public:
			hook_pointer() { }
			hook_pointer(hook_ptr p) { base::current=p? (void_ptr_ptr) p : 0; }
			~hook_pointer() { }
/*
	"const pointer &" can't be zero, so no need to safely test against it.

	A proper amount of memory needs to be allocated for "current" when constructed,
	otherwise there will be subtle and strange bugs and behaviours!
*/
//			hook_pointer(const hook_pointer & p) { current=p.current; }
/*
	In the case p == this, nothing is changed.

	This version is needed for compatibility with the existing constructors, to accept "=new pointer()" code.

	Allows for potential memory leak. Burden is placed on the api coder.
			const hook_pointer & operator = (void_ptr p)
			{
				current=p? new void_ptr[N] : 0;
				return *this;
			}
*/
/*
	In the case &p == this, nothing is changed.

	Allows for potential memory leak. Burden is placed on the api coder.
*/
/*
			const hook_pointer & operator = (const hook_pointer & p)
			{
				base::current=p.current;
				return *this;
			}
*/
	};
  }
 }
}

#endif
